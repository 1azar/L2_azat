Что выведет программа? Объяснить вывод программы.
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	c := make(chan int)

	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}

		close(c)
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()
	return c
}

func main() {

	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4 ,6, 8)
	c := merge(a, b )
	for v := range c {
		fmt.Println(v)
	}
}

```
Ответ:
```
будут выводится числа пока один из каналов (a,b) или оба не закроются, после чего выводится будет , только zeroValue для int - "0":
1
2
3
4
6
8
5
0
0
0
0
...
```
- Создаются две горутины, которые записывают в небуферизированные каналы a и b соответсвующее числа через (от 0 до 1) секунд
после прочтения значения из канала, когда числа закончатся каналы закрываются. Каналы закроются в разный момент времени.
- Далее создается еще одна горутина, которая слушает каналы используя оператор `select` и каждый раз когда приходит новое значение в один из каналов
`a` и `b` записывает это значение в третий небуферизированные канал `c`. 
  - Так как при чтении `select'ом` из закрытого канала рессивер сразу получает zeroValue для типа, который передает канал, поэтому как только один из каналов
  `a` или `b` закроется `select` будет "проваливаться" в `case` с закрытым каналом и записывать 0 в канал `c`.
  - Для исправления ошибочного поведения необходимо принимать второй параметр, который говорить о статусе канала и при его закрытости за'nil'ить канал, чтобы этот `case` больше не выполнялся (см. листинг 2).
  - так же канал `c` не закрывается, что привело бы deadlock'у. В теле цикла for можно проверять каналы `a`, `b` на `nil` и если оба `nil` -> закрыть канал `c` и `break` (см. листинг 2)
- основная горутина в `main` останавливается на цикле `for v:= range c {...}` который слушает 3ий из каналов - `c`. И выводит данные, которые туда приходят в консоль.

листинг 2:
```go
for {
  select {
    case v, ok := <-a:
      if !ok {
        a = nil
      } else {
        c <- v
      }
    case v, ok := <-b:
      if !ok {
        b = nil
      } else {
        c <- v
      }
  }
  
  if a == nil && b == nil {
    close(c)
    break
  }
}
```