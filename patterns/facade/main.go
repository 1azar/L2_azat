package main

import (
	walletFacade2 "L2_azat/patterns/facade/walletFacade" // Клиентское приложение зависит напрямую только от фасада
	"fmt"
	"log"
)

/*
Фасад — это структурный паттерн, который предоставляет высокоуровневый интерфейс к сложной системе объектов,
библиотеке или фреймворку. Клиент взаимодействует с фасадом вместо работы с объектами сложной подсистемы.

Проблема:
Бизнес логика классов тесно переплетается с деталями реализации сторонних классов (зависимостей).
Такой код трудно понимать и поддерживать тк необходимо вникать в принципы работы каждой используемой зависимости.

Фасад - это интерфейс для взаимодействия со сложной подсистемой, но этот интерфейс реализует всю необходимую
разрабатываемому приложению функциональность. Хоть я и не будете иметь 100% возможностей используемой подсистемы,
но они в данном случае и не нужны все.

Фасад полезен, если для решения одной задачи требуется применения множества библиотек, зависимостей, других классов,
которые взаимодействуют друг с другом, имеют множество параметров. Но вместо того, чтобы писать весь код в бизнес логике (БЛ)
выносишь всё в отдельный класс/метод, а в БЛ дергается одна единственная "ручка" фасада, которая за собой таит
всю магию взаимодействия с зависимостями.

Преимущества:
	1) при смене фреймворка/библиотеки нет необходимости менять код основного приложения, требуется переписать только фасад
	2) изолирует клиент от компонентов сложной подсистемы, делает его лаконичнее, проще и абстрактнее в понимании.
	3) DRY подход - избавляет от повторяющегося кода, делает его чище
	4) снижение зависимостей между клиентским кодом и внутренними реализациями подсистемы


Недостатки:
	1) фасад имеет риск стать "божественным объектом" для приложения от которого зависят множество его классов,
		что повысит жесткость "архитектуры". Для предотвращения этого нужно отслеживать фасад и при его разрастании
		и "размытии" делить один большой на несколько малых фасадов
	2) ограничивает функции подсистем, работа производится только через относительно урезанный интерфейс

Сценарии применимости:
	1) необходимо скрыть сложность подсистемы, убрать "технический" код из бизнес-логики, отгородиться от
		деталей реализации низкоуровневых или иных компонент
	2) улучшить читаемость кода, уменьшить сложность
	3) предоставить стабильный интерфейс для приложения, когда планируется изменить реализацию внешних систем, сменить фреймворк, базу данных
	4) интеграция с другими системами
	5) простота тестирования когда еще не реализованы внешние системы можно их "замокать" и тестировать бизнес логику изолировано
*/

/*
Пример - кошелек (walletFacade.go), который имеет конструктор и два метода (зачислить деньги, снять деньги) - это фасад.
Внутри себя для осуществления данных операция требуется взаимодействие с многими подсистемами (валидация данных,
проверка баланса, запись в бухгалтерской книге, отправка оповещений и тд).
*/

// Наш клиентский код
func main() {
	// инициализация фасада
	walletFacade := walletFacade2.NewWalletFacade("myWBWallet", 1234)
	fmt.Println()

	// Зачисление денег в кошелек. Используется один метод фасада в бизнес логике - addMoneyToWallet, однако за фасадом используется
	// множество подсистем (проверка аккаунта, проверка securityCode, зачисление денег, отправка оповещений, запись в бух книгу)
	// но клиенту (этому коду) не нужно знать обо всем об этом, его задача просто пополнить баланс и он остальную работу делегирует фасаду
	err := walletFacade.AddMoneyToWallet("myWBWallet", 1234, 10)
	if err != nil {
		log.Fatalf("Error: %s\n", err.Error())
	}

	fmt.Println()

	// То же самое для снятия денег с кошелька
	err = walletFacade.DeductMoneyFromWallet("myWBWallet", 1234, 5)
	if err != nil {
		log.Fatalf("Error: %s\n", err.Error())
	}

}
